use crate::metadata::BenchmarkCrate;
use std::path::Path;

/// Generate runner.rs source code
///
/// Creates a Rust program that:
/// 1. Declares extern crate for all benchmark crates
/// 2. Supports `--list` flag to output benchmark names as JSON
/// 3. Runs a single benchmark when SIMPLEBENCH_BENCH_FILTER is set (exact match)
/// 4. Falls back to streaming mode for backwards compatibility
pub fn generate_runner(benchmark_crates: &[BenchmarkCrate]) -> String {
    let mut code = String::new();

    // Add header comment
    code.push_str("// Generated by cargo-simplebench\n");
    code.push_str("// This runner collects and executes benchmarks from the workspace\n\n");

    // Add extern declarations for runtime crates
    code.push_str("extern crate simplebench_runtime;\n");
    code.push_str("extern crate inventory;\n\n");

    // Add extern declarations for all benchmark crates
    for crate_info in benchmark_crates {
        let crate_name = crate_info.name.replace('-', "_");
        code.push_str(&format!("extern crate {};\n", crate_name));
    }

    code.push('\n');

    // Add main function with three modes:
    // 1. --list: Output benchmark names as JSON
    // 2. SIMPLEBENCH_BENCH_FILTER set: Run single benchmark, output JSON
    // 3. Neither: Fall back to streaming mode (backwards compatibility)
    code.push_str("fn main() {\n");
    code.push_str("    let args: Vec<String> = std::env::args().collect();\n\n");

    code.push_str("    // Change to workspace root for baseline storage\n");
    code.push_str(
        "    if let Ok(workspace_root) = std::env::var(\"SIMPLEBENCH_WORKSPACE_ROOT\") {\n",
    );
    code.push_str("        if let Err(e) = std::env::set_current_dir(&workspace_root) {\n");
    code.push_str("            eprintln!(\"Failed to change to workspace root: {}\", e);\n");
    code.push_str("            std::process::exit(1);\n");
    code.push_str("        }\n");
    code.push_str("    }\n\n");

    // Mode 1: --list flag
    code.push_str("    // Mode 1: List benchmarks as JSON\n");
    code.push_str("    if args.iter().any(|a| a == \"--list\") {\n");
    code.push_str("        simplebench_runtime::list_benchmarks_json();\n");
    code.push_str("        return;\n");
    code.push_str("    }\n\n");

    code.push_str("    // Load configuration (file + env overrides)\n");
    code.push_str("    let config = simplebench_runtime::BenchmarkConfig::load();\n\n");

    // Mode 2: Single benchmark execution (parallel worker mode)
    code.push_str("    // Mode 2: Single benchmark execution (for parallel mode)\n");
    code.push_str("    if std::env::var(\"SIMPLEBENCH_SINGLE_BENCH\").is_ok() {\n");
    code.push_str("        simplebench_runtime::run_single_benchmark_json(&config);\n");
    code.push_str("        return;\n");
    code.push_str("    }\n\n");

    // Mode 3: Streaming mode (backwards compatibility)
    code.push_str("    // Mode 3: Streaming mode (backwards compatibility)\n");
    code.push_str("    use simplebench_runtime::{\n");
    code.push_str("        run_and_stream_benchmarks,\n");
    code.push_str("        process_with_baselines,\n");
    code.push_str("        check_regressions_and_exit,\n");
    code.push_str("    };\n\n");

    code.push_str("    let results = run_and_stream_benchmarks(&config);\n\n");

    code.push_str("    if results.is_empty() {\n");
    code.push_str("        eprintln!(\"ERROR: No benchmarks found!\");\n");
    code.push_str(
        "        eprintln!(\"Make sure your benchmark functions are marked with #[bench]\");\n",
    );
    code.push_str("        std::process::exit(1);\n");
    code.push_str("    }\n\n");

    code.push_str("    // Check for regressions and exit if in CI mode\n");
    code.push_str("    if config.comparison.ci_mode {\n");
    code.push_str(
        "        if let Ok(comparisons) = process_with_baselines(&results, &config.comparison) {\n",
    );
    code.push_str("            check_regressions_and_exit(&comparisons, &config.comparison);\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    code
}

/// Write runner.rs to a file
pub fn write_runner(
    target_dir: &Path,
    benchmark_crates: &[BenchmarkCrate],
) -> Result<std::path::PathBuf, std::io::Error> {
    let runner_code = generate_runner(benchmark_crates);
    let runner_path = target_dir.join("simplebench_runner.rs");
    std::fs::write(&runner_path, runner_code)?;
    Ok(runner_path)
}
